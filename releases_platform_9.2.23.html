​<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Notas de Release: Platform 9.2.23 - Observabilidad</title>

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" />

    <style>
        /* Importación de Fuentes de Google Fonts */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&family=Fira+Code:wght@400&display=swap');

        /* Variables CSS para la Paleta de Colores */
        :root {
            --bg-color: #f4f7f9;
            --card-bg-color: #ffffff;
            --text-color: #212529;
            --text-muted-color: #6c757d;
            --border-color: #dee2e6;
            --primary-color: #0056b3;
            --analysis-bg: #e6f7ff;
            --analysis-border: #91d5ff;
            --deployment-bg: #f0fdf4;
            --deployment-border: #86efac;
        }

        /* Estilos Base */
        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            padding: 2em;
            line-height: 1.7;
        }

        .container {
            max-width: 960px;
            margin: 0 auto;
        }

        /* Encabezado Principal */
        .main-header {
            background-color: var(--card-bg-color);
            padding: 2em;
            border-radius: 8px;
            border: 1px solid var(--border-color);
            margin-bottom: 2.5em;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);
        }

        .main-header h1 {
            margin: 0 0 0.25em 0;
            font-size: 2.2em;
            color: var(--primary-color);
        }

        .main-header p {
            margin: 0;
            font-size: 1.1em;
            color: var(--text-muted-color);
        }

        /* Información de Despliegue */
        .deployment-info-box {
            background-color: var(--deployment-bg);
            border-left: 4px solid var(--deployment-border);
            padding: 1em 1.5em;
            margin-bottom: 2.5em;
            border-radius: 4px;
        }

        .deployment-info-box h4 {
            margin-top: 0;
            font-size: 1.2em;
            color: #166534;
        }

        .deployment-info-box p {
            margin: 0.5em 0 0 0;
            font-family: 'Fira Code', monospace;
            font-size: 0.95em;
        }

        /* Secciones de Servicio */
        .service-section {
            margin-bottom: 3em;
        }

        .service-section>h2 {
            font-size: 1.8em;
            color: var(--primary-color);
            border-bottom: 2px solid var(--border-color);
            padding-bottom: 0.5em;
            margin-bottom: 1.5em;
        }

        /* Tarjeta de Componente (details) */
        .component-card {
            background-color: var(--card-bg-color);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            margin-bottom: 2em;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);
            overflow: hidden;
        }

        /* Encabezado de la Tarjeta (summary) */
        .component-header {
            padding: 1em 1.5em;
            background-color: #fafafa;
            border-bottom: 1px solid var(--border-color);
            cursor: pointer;
            list-style: none; /* Oculta el marcador de triángulo por defecto */
        }

        /* Oculta el marcador de triángulo en WebKit (Chrome/Safari) */
        .component-header::-webkit-details-marker {
            display: none;
        }

        .component-header h3 {
            margin: 0;
            font-family: 'Fira Code', monospace;
            font-size: 1.2em;
        }

        /* Cuerpo de la Tarjeta */
        .component-body {
            padding: 1.5em;
        }

        .component-body h4 {
            margin-top: 1.5em;
            margin-bottom: 0.5em;
            font-size: 1.2em;
            color: #343a40;
        }

        .component-body h5 {
            margin-top: 1.5em;
            margin-bottom: 0.5em;
            font-size: 1.1em;
            font-weight: 700;
        }

        /* Caja de Conclusión del Análisis */
        .analysis-box {
            background-color: var(--analysis-bg);
            border-left: 4px solid var(--analysis-border);
            padding: 1em 1.5em;
            margin-top: 1.5em;
            border-radius: 4px;
        }

        .analysis-box h4 {
            margin-top: 0;
            font-size: 1.1em;
            color: var(--primary-color);
        }

        /* Bloques de Código (Prism.js) */
        pre[class*="language-"] {
            padding: 1.2em !important;
            margin: 1em 0 !important;
            border-radius: 6px;
            font-family: 'Fira Code', monospace !important;
            font-size: 0.9em !important;
            line-height: 1.5 !important;
            border: 1px solid var(--border-color);
            /* CRÍTICO: Ajuste de código para evitar el scroll horizontal */
            white-space: pre-wrap;
            word-break: break-all;
        }
    </style>
</head>

<body>

    <div class="container">
        <header class="main-header">
            <h1>Notas de Release: Platform 9.2.23</h1>
            <p>
                Implementación de sistema de Observabilidad y métricas de latencia.
            </p>
        </header>

        <div class="deployment-info-box">
            <h4>Información de Despliegue</h4>
            <p><b>Versión:</b> 9.2.23</p>
            <p><b>Fecha de Despliegue:</b> [Pendiente]</p>
            <p><b>AWS Task:</b> [Pendiente]</p>
            <p><b>Commits:</b> 9475759c9c7ed0b4b89ab7ce9ec9ab2b2f65df66</p>
        </div>

        <section id="summary" class="service-section">
            <h2>Resumen General de la Versión</h2>
            <p>
                Esta actualización introduce una nueva capacidad de observabilidad mediante la creación de la colección <code>orderTime</code>. El propósito fundamental es medir con precisión de milisegundos el "tiempo de residencia" de una solicitud de orden dentro del servidor. Esto permite identificar cuellos de botella, latencia en la base de datos o retrasos en el procesamiento lógico por plataforma y sucursal.
            </p>
        </section>

        <section id="technical-analysis" class="service-section">
            <h2>Análisis Técnico Detallado</h2>

            <!-- Bloque para api/src/models/orderTime.js -->
            <details class="component-card" open>
              <summary class="component-header">
                <h3>api/src/models/orderTime.js (Nuevo Archivo)</h3>
              </summary>
              <div class="component-body">
                  <h4>Análisis General</h4>
                  <p>
                    Se define el nuevo esquema de Mongoose para almacenar métricas de latencia. Este modelo está optimizado para registros manuales de tiempo, desactivando los timestamps automáticos.
                  </p>
                  
                  <h4>Cambios Detallados</h4>
            
                  <h5>Definición del Esquema de Métricas</h5>
                  <p><b>Explicación:</b> Se crea la estructura de datos con los campos clave: <code>entryDate</code> (inicio), <code>responseDate</code> (fin), <code>branch</code>, <code>order</code> y <code>platform</code>. La diferencia entre <code>responseDate</code> y <code>entryDate</code> determinará el tiempo total de procesamiento.</p>
                  <b>Código Nuevo:</b>
                  <pre><code class="language-javascript">
// NUEVO ARCHIVO: Esquema para almacenar métricas de latencia
import mongoose, { Schema } from 'mongoose'
import uniqueValidator from 'mongoose-unique-validator'

const orderTimeSchema = new Schema({
    entryDate: { type: Date },      // Inicio del procesamiento
    responseDate: { type: Date },   // Fin del procesamiento
    branch: { type: String },
    order: { type: String },
    platform: { type: String }
}, {
    strict: false,
    timestamps: false
});

orderTimeSchema.plugin(uniqueValidator);
orderTimeSchema.plugin(require('@meanie/mongoose-to-json'));

module.exports = mongoose.model('orderTime', orderTimeSchema);
                  </code></pre>
                  
                  <div class="analysis-box">
                  <h4>Conclusión del análisis</h4>
                  <p>Este modelo actúa como la base de datos para la observabilidad, permitiendo segmentar el rendimiento por sucursal y plataforma.</p>
                </div>
              </div>
            </details>
          
          <details class="component-card" open>
  <summary class="component-header">
    <h3>Documentación Técnica: Atributos de la Colección orderTime</h3>
  </summary>
  <div class="component-body">
      <h4>Descripción del Esquema</h4>
      <p>
        La colección <code>orderTime</code> está diseñada para medir y registrar los tiempos de procesamiento de órdenes en el sistema. Cada documento representa una métrica de rendimiento para una orden específica procesada por una plataforma de delivery.
      </p>

      <h4>Detalle de Atributos</h4>

      <h5>1. entryDate (Tipo: Date)</h5>
      <p>
        <b>Qué mide:</b> La fecha y hora exacta en que comienza el procesamiento de la solicitud de orden en el servidor.<br>
        <b>Propósito:</b> Marca el punto de entrada de la solicitud, permitiendo calcular el tiempo total de procesamiento desde que el servidor recibe la petición hasta que responde.
      </p>
      <b>Momento de captura:</b>
      <p>Se registra inmediatamente al inicio de la función controladora correspondiente, justo después de la declaración <code>try</code>.</p>
      <pre><code class="language-javascript">
const saveOrder = async (req, res) => {
  try {
    const entryDate = new Date();  // ← Aquí se captura entryDate
    // ... resto del código
  }
      </code></pre>

      <h5>2. responseDate (Tipo: Date)</h5>
      <p>
        <b>Qué mide:</b> La fecha y hora exacta en que finaliza el procesamiento exitoso de la orden y se envía la respuesta al cliente.<br>
        <b>Propósito:</b> Marca el punto de salida, permitiendo calcular la duración total del procesamiento.
      </p>
      <b>Momento de captura:</b>
      <p>Se registra en el momento de crear el registro en la base de datos, justo antes de enviar la respuesta HTTP.</p>
      <pre><code class="language-javascript">
await orderTimeModel.create({
  entryDate: entryDate,
  responseDate: new Date(),  // ← Aquí se captura responseDate
  // ... otros campos
})
return res.status(200).json({...}).end();
      </code></pre>

      <h5>3. branch (Tipo: String)</h5>
      <p>
        <b>Qué mide:</b> El identificador único de la sucursal que está procesando la orden.<br>
        <b>Propósito:</b> Permite segmentar las métricas por sucursal, facilitando análisis de rendimiento por ubicación geográfica o establecimiento específico.<br>
        <b>Momento de captura:</b> Se obtiene del objeto de orden o de la consulta a la base de datos de sucursales.
      </p>
      <ul>
        <li><b>MercadoPago / PedidosYa:</b> <code>currentBranch.branchId</code></li>
        <li><b>ThirdParty:</b> <code>resultPromise[0].branchId</code> (arrays) o <code>req.body.branchId</code></li>
      </ul>

      <h5>4. order (Tipo: String)</h5>
      <p>
        <b>Qué mide:</b> El identificador único de la orden que se está procesando.<br>
        <b>Propósito:</b> Vincula las métricas de tiempo directamente con órdenes específicas.<br>
        <b>Momento de captura:</b> Se obtiene del cuerpo de la solicitud (req.body) o del objeto de orden procesado.
      </p>
      <ul>
        <li><b>MercadoPago:</b> <code>req.body.meta.resource_id</code></li>
        <li><b>PedidosYa:</b> <code>req.body.code</code></li>
        <li><b>UberEats:</b> ID generado internamente (<code>newId</code>)</li>
      </ul>

      <h5>5. platform (Tipo: String)</h5>
      <p>
        <b>Qué mide:</b> El nombre de la plataforma de delivery que originó la orden.<br>
        <b>Propósito:</b> Permite segmentar las métricas por plataforma para comparaciones.<br>
        <b>Valores típicos:</b> "MercadoPago", "PedidosYa", "UberEats" o dinámico para ThirdParty.
      </p>

      <div class="analysis-box">
      <h4>Cálculo y Consideraciones</h4>
      <p><b>Fórmula:</b> <code>processingTime = responseDate - entryDate</code></p>
      <p>
          Este cálculo representa el tiempo neto de procesamiento interno (validaciones, BD, APIs externas), excluyendo la latencia de red cliente-servidor.
      </p>
      <p><b>Nota Importante:</b> Solo se registra para casos de procesamiento exitoso; si ocurre un error, no se crea el registro.</p>
    </div>
  </div>
</details>
            
            <!-- Bloque para api/src/controllers/mercadoPago.js -->
            <details class="component-card" open>
              <summary class="component-header">
                <h3>api/src/controllers/mercadoPago.js</h3>
              </summary>
              <div class="component-body">
                  <h4>Análisis General</h4>
                  <p>
                    Se instrumenta el controlador de notificaciones de MercadoPago para registrar el tiempo que toma procesar una notificación entrante.
                  </p>
                  
                  <h4>Cambios Detallados</h4>
            
                  <h5>Captura y Registro de Tiempos</h5>
                  <p><b>Explicación:</b> Se inicializa <code>entryDate</code> al principio de la ejecución y se guarda el registro en <code>orderTimeModel</code> justo antes de devolver el estado 200 al webhook.</p>
                  <b>Código Anterior:</b>
                  <pre><code class="language-javascript">
// ANTES: Procesamiento estándar sin métricas
const mercadoPagoNotification = async (req, res) => {
  try {
    Log.saveError(null, { message: 'Received MercadoPago notification', data: req.body, platform: 'MercadoPago' });
                  </code></pre>
                  <b>Código Nuevo:</b>
                  <pre><code class="language-javascript">
// DESPUÉS: Inicio de cronómetro y guardado final
const mercadoPagoNotification = async (req, res) => {
  try {
    const entryDate = new Date(); // Captura inicio
    Log.saveError(null, { message: 'Received MercadoPago notification', data: req.body, platform: 'MercadoPago' });
    // ... lógica de procesamiento ...
    await orderTimeModel.create({
      entryDate: entryDate,
      responseDate: new Date(),   // Captura fin
      branch: currentBranch.branchId,
      order: orderId,
      platform: "MercadoPago"
    })
    return res.status(200).json({}).end();
                  </code></pre>
                  
                  <div class="analysis-box">
                  <h4>Conclusión del análisis</h4>
                  <p>Habilita la medición de latencia para todas las notificaciones provenientes de MercadoPago.</p>
                </div>
              </div>
            </details>
            
            <!-- Bloque para api/src/controllers/peya.js -->
            <details class="component-card" open>
              <summary class="component-header">
                <h3>api/src/controllers/peya.js</h3>
              </summary>
              <div class="component-body">
                  <h4>Análisis General</h4>
                  <p>
                    Implementación similar para PedidosYa. Se asegura que el registro del tiempo solo ocurra en el flujo exitoso de guardado de orden (<code>saveOrder</code>).
                  </p>
                  
                  <h4>Cambios Detallados</h4>
            
                  <h5>Instrumentación en saveOrder</h5>
                  <p><b>Explicación:</b> Se reestructura el bloque <code>else</code> (éxito) para incluir la llamada asíncrona a <code>orderTimeModel.create</code> antes de responder a la API de PedidosYa.</p>
                  <b>Código Anterior:</b>
                  <pre><code class="language-javascript">
// ANTES: Respuesta inmediata sin registro de tiempos
            else
                res.status(200).json({...}).end();
                  </code></pre>
                  <b>Código Nuevo:</b>
                  <pre><code class="language-javascript">
// DESPUÉS: Bloque else con registro de métricas
            else {
                await orderTimeModel.create({
                    entryDate: entryDate,
                    responseDate: new Date(),
                    branch: currentBranch.branchId,
                    order: req.body.code,
                    platform: "PedidosYa"
                })
                res.status(200).json({...}).end();
            }
                  </code></pre>
                  
                  <div class="analysis-box">
                  <h4>Conclusión del análisis</h4>
                  <p>Permite auditar el tiempo de procesamiento de pedidos exitosos en PedidosYa.</p>
                </div>
              </div>
            </details>
            
            <!-- Bloque para api/src/controllers/thirdParty.js -->
            <details class="component-card" open>
              <summary class="component-header">
                <h3>api/src/controllers/thirdParty.js</h3>
              </summary>
              <div class="component-body">
                  <h4>Análisis General</h4>
                  <p>
                    Se actualiza el controlador genérico de terceros para soportar la medición de tiempos tanto para órdenes individuales como para arrays de órdenes.
                  </p>
                  
                  <h4>Cambios Detallados</h4>
            
                  <h5>Soporte Asíncrono en Promises</h5>
                  <p><b>Explicación:</b> Se convierten los callbacks de <code>.then()</code> a funciones <code>async</code> para permitir el uso de <code>await orderTimeModel.create(...)</code> antes de enviar la respuesta.</p>
                  <b>Código Anterior:</b>
                  <pre><code class="language-javascript">
// ANTES: Callback síncrono
  Promise.all(resultProm)
    .then((resultPromise) => {
      res.status(200).send(resultPromise).end();
    })
                  </code></pre>
                  <b>Código Nuevo:</b>
                  <pre><code class="language-javascript">
// DESPUÉS: Callback asíncrono con registro de tiempo
  Promise.all(resultProm)
    .then(async (resultPromise) => {  
      await orderTimeModel.create({
          entryDate: entryDate,
          responseDate: new Date(),
          branch: resultPromise[0].branchId,
          order: resultPromise[0].id,
          platform: platform._platform.name
      })
      res.status(200).send(resultPromise).end();
    })
                  </code></pre>
                  
                  <div class="analysis-box">
                  <h4>Conclusión del análisis</h4>
                  <p>Extiende la capacidad de observabilidad a todas las integraciones de terceros gestionadas por este controlador.</p>
                </div>
              </div>
            </details>
            
            <!-- Bloque para api/src/controllers/uberEats.js -->
            <details class="component-card" open>
              <summary class="component-header">
                <h3>api/src/controllers/uberEats.js</h3>
              </summary>
              <div class="component-body">
                  <h4>Análisis General</h4>
                  <p>
                    Se añade la lógica de medición de tiempo específicamente para el evento <code>orders.notification</code> dentro del webhook de Uber Eats.
                  </p>
                  
                  <h4>Cambios Detallados</h4>
            
                  <h5>Registro en Notificación de Orden</h5>
                  <p><b>Explicación:</b> Se captura el inicio del evento y se guarda la métrica al finalizar el procesamiento de la notificación, utilizando el ID de orden interno generado.</p>
                  <b>Código Anterior:</b>
                  <pre><code class="language-javascript">
// ANTES:
    case 'orders.notification':
      try {
          const orderId = req.body.meta.resource_id;
                  </code></pre>
                  <b>Código Nuevo:</b>
                  <pre><code class="language-javascript">
// DESPUÉS:
    case 'orders.notification':
      try {
          const entryDate = new Date(); // Inicio
          const orderId = req.body.meta.resource_id;
          // ... lógica ...
           await orderTimeModel.create({
              entryDate: entryDate,
              responseDate: new Date(),
              branch: currentBranch.branchId,
              order: newId,
              platform: "UberEats"
            })
          return res.status(200).json({}).end();
                  </code></pre>
                  
                  <div class="analysis-box">
                  <h4>Conclusión del análisis</h4>
                  <p><b>Impacto Clave:</b> Diagnóstico preciso de tiempos de respuesta, optimización basada en datos reales (entryDate vs responseDate) y transparencia en los tiempos de servicio internos (SLA).</p>
                </div>
              </div>
            </details>

        </section>
    </div>

    <!-- Scripts de Prism.js para resaltar código -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>

</body>
</html>
