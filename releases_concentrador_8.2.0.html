<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Notas de Release: Concentrador 8.2.0</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" />
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&family=Fira+Code:wght@400&display=swap');

        :root {
            --bg-color: #f4f7f9;
            --card-bg-color: #ffffff;
            --text-color: #212529;
            --text-muted-color: #6c757d;
            --border-color: #dee2e6;
            --primary-color: #0056b3;
            --analysis-bg: #e6f7ff;
            --analysis-border: #91d5ff;
            --deployment-bg: #f0fdf4;
            --deployment-border: #86efac;
        }

        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            padding: 2em;
            line-height: 1.7;
        }

        .container {
            max-width: 960px;
            margin: 0 auto;
        }

        .main-header {
            background-color: var(--card-bg-color);
            padding: 2em;
            border-radius: 8px;
            border: 1px solid var(--border-color);
            margin-bottom: 2.5em;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);
        }

        .main-header h1 {
            margin: 0 0 0.25em 0;
            font-size: 2.2em;
            color: var(--primary-color);
        }

        .main-header p {
            margin: 0;
            font-size: 1.1em;
            color: var(--text-muted-color);
        }

        .deployment-info-box {
            background-color: var(--deployment-bg);
            border-left: 4px solid var(--deployment-border);
            padding: 1em 1.5em;
            margin-bottom: 2.5em;
            border-radius: 4px;
        }

        .deployment-info-box h4 {
            margin-top: 0;
            font-size: 1.2em;
            color: #166534;
        }

        .deployment-info-box p {
            margin: 0.5em 0 0 0;
            font-family: 'Fira Code', monospace;
            font-size: 0.95em;
        }

        .service-section {
            margin-bottom: 3em;
        }

        .service-section>h2 {
            font-size: 1.8em;
            color: var(--primary-color);
            border-bottom: 2px solid var(--border-color);
            padding-bottom: 0.5em;
            margin-bottom: 1.5em;
        }

        .component-card {
            background-color: var(--card-bg-color);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            margin-bottom: 2em;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);
            overflow: hidden;
        }

        .component-header {
            padding: 1em 1.5em;
            background-color: #fafafa;
            border-bottom: 1px solid var(--border-color);
            cursor: pointer;
            list-style: none;
        }

        .component-header::-webkit-details-marker {
            display: none;
        }

        .component-header h3 {
            margin: 0;
            font-family: 'Fira Code', monospace;
            font-size: 1.2em;
        }

        .component-body {
            padding: 1.5em;
        }

        .component-body h4 {
            margin-top: 1.5em;
            margin-bottom: 0.5em;
            font-size: 1.2em;
            color: #343a40;
        }

        .component-body h5 {
            margin-top: 1.5em;
            margin-bottom: 0.5em;
            font-size: 1.1em;
            font-weight: 700;
        }

        .analysis-box {
            background-color: var(--analysis-bg);
            border-left: 4px solid var(--analysis-border);
            padding: 1em 1.5em;
            margin-top: 1.5em;
            border-radius: 4px;
        }

        .analysis-box h4 {
            margin-top: 0;
            font-size: 1.1em;
            color: var(--primary-color);
        }

        pre[class*="language-"] {
            padding: 1.2em !important;
            margin: 1em 0 !important;
            border-radius: 6px;
            font-family: 'Fira Code', monospace !important;
            font-size: 0.9em !important;
            line-height: 1.5 !important;
            border: 1px solid var(--border-color);
            white-space: pre-wrap;
            word-break: break-all;
        }
    </style>
</head>

<body>
    <div class="container">
        <header class="main-header">
            <h1>Notas de Release: Concentrador 8.2.0</h1>
            <p>Mejoras en el manejo de rechazos, integración con el sistema de lealtad (SML) y optimización de la búsqueda de novedades.</p>
        </header>

        <div class="deployment-info-box">
            <h4>Información de Despliegue</h4>
            <p><b>Versión:</b> 8.2.0</p>
            <p><b>Fecha de Despliegue:</b> 2025-10-01</p>
            <p><b>Entorno:</b> Producción</p>
            <p><b>Commits:</b> 405dc71, 1105fa2, 20eeb11</p>
        </div>

        <section id="summary" class="service-section">
            <h2>Resumen General</h2>
            <p>
                Este release se enfoca en mejorar la **robustez y la consistencia del sistema de pedidos**, especialmente para aquellos que involucran la funcionalidad de canje de puntos con el sistema de lealtad externo **SML (SmartLoyalty)**. Además, introduce una mejora significativa en la funcionalidad de búsqueda de novedades.
            </p>
            <p>
                Los cambios clave incluyen:
            </p>
            <ul>
                <li>
                    <strong>Integración con SML:</strong> Se implementa un flujo de compensación que se activa cuando un pedido con canje de puntos no se puede confirmar con la plataforma de delivery. En este escenario, el Concentrador revierte automáticamente el canje de puntos con SML para evitar que los clientes pierdan sus puntos.
                </li>
                <li>
                    <strong>Notificación al POS:</strong> Para los casos de rechazo de canjes, se ha creado un mecanismo para enviar una notificación de rechazo específica al POS, asegurando que el local esté al tanto del estado del pedido.
                </li>
                <li>
                    <strong>Búsqueda Multi-filtro:</strong> Se refactoriza la API de búsqueda de novedades para permitir el uso de múltiples valores para un mismo filtro (ej. buscar novedades de varias plataformas a la vez), lo que mejora drásticamente la experiencia de usuario y la eficiencia.
                </li>
            </ul>
        </section>

        <section id="technical-analysis" class="service-section">
            <h2>Análisis Técnico Detallado</h2>
            <details class="component-card">
                <summary class="component-header">
                    <h3>api/src/controllers/branch.js</h3>
                </summary>
                <div class="component-body">
                    <h4>Análisis General</h4>
                    <p>
                        Esta actualización, como parte de la iniciativa de <strong>Integración con Sistema de Lealtad (SML)</strong>, introduce una nueva capa de lógica de negocio para manejar de manera robusta los rechazos de pedidos que involucran canjes de puntos. El objetivo principal es asegurar la consistencia de los datos entre el Concentrador y el sistema de lealtad (SML), implementando un flujo de compensación para los casos en que la confirmación de un pedido con canje falla en la plataforma de delivery.
                    </p>
                    <p>
                        Los cambios clave incluyen:
                    </p>
                    <ul>
                        <li><strong>Integración con SML:</strong> Se ha añadido la lógica completa para autenticarse con la API de SML y gestionar la renovación automática de su token.</li>
                        <li><strong>Nuevo Flujo de Compensación:</strong> Se ha creado una nueva función que se activa cuando falla la confirmación de un pedido con canje. Esta función se encarga de actualizar el estado del pedido en el Concentrador, registrar el evento como una "novedad" de rechazo y, lo más importante, notificar a la API de SML para que revierta el canje de puntos.</li>
                        <li><strong>Mejora en la Lógica de Re-procesamiento:</strong> Las funciones existentes (`orderRejClosed` y `rejectOrdersPeya`) han sido modificadas para incorporar esta nueva lógica de compensación, asegurando que los pedidos con canjes sean tratados de manera especial en caso de error.</li>
                    </ul>

                    <h4>Cambios Detallados</h4>
                    <h5>1. Nuevas Dependencias y Variables Globales</h5>
                    <p><b>Explicación:</b> Se han importado nuevos modelos (`newsStatesModel`, `newsTypesModel`, `rejectedMessageModel`) y se han añadido variables globales (`stateRej`, `typeRej`, `rejectedExtraData`) para cargar y almacenar configuraciones de rechazo desde la base de datos. Esto permite que la nueva lógica de rechazo utilice datos dinámicos en lugar de valores fijos, mejorando la mantenibilidad.</p>
                    <b>Código Nuevo:</b>
                    <pre><code class="language-javascript">
// DESPUÉS: Se importan los modelos necesarios para la nueva lógica de rechazo.
// ...
import openClosedLogModel from '../models/openClosedLog';
import newsStatesModel from '../models/newsState';
import newsTypesModel from '../models/newsType';
import rejectedMessageModel from '../models/rejectedMessage';
import countryModel from '../models/country';
// ...
// Se declaran variables globales para almacenar configuraciones que se cargarán al inicio.
let stateRej = {};
let typeRej = {};
let rejectedExtraData = {};
// ... dentro de la función tokensLoad() ...
// Se cargan las configuraciones de rechazo desde la base de datos al iniciar la aplicación.
async function tokensLoad() {
  // ...
  stateRej = await newsStatesModel.findOne({cod: "rej"});
  typeRej = await newsTypesModel.findOne({cod: "rej_ord"});
  rejectedExtraData = await rejectedMessageModel.findOne({id: -10});
  // ...
}
                    </code></pre>
                    <h5>2. Lógica de Autenticación con SML</h5>
                    <p><b>Explicación:</b> Se han introducido dos nuevas funciones, `SMLLogin` y `checkAndRenewToken`, para gestionar el ciclo de vida del token de autenticación con la API de SML. `SMLLogin` obtiene un nuevo token, mientras que `checkAndRenewToken` lo renueva automáticamente si está a punto de expirar. Esto asegura que el sistema siempre tenga un token válido para comunicarse con SML.</p>
                    <b>Código Nuevo:</b>
                    <pre><code class="language-javascript">
// DESPUÉS: Se añade la lógica para autenticarse y renovar el token de SML.
async function SMLLogin() {
  try {
    const body = { /* ... credenciales de SML ... */ };
    await axios.post(`${settings.smlParams.url}`, body).then(r => {
      // Se almacena el token y su fecha de expiración en variables globales.
      tokenSML = r.data.access_token;
      expires_in = Date.now() + (r.data.expires_in * 1000);
    });
  } catch (error) { /* ... */ }
}
async function checkAndRenewToken() {
  const tiempoRestante = (expires_in - Date.now()) / 1000;
  // Si no hay token o expira en menos de 200 segundos, se solicita uno nuevo.
  if (!tokenSML || tiempoRestante <= 200) {
    await SMLLogin(); 
  }
}
                    </code></pre>
                    <h5>3. Nueva Función de Compensación (`sendRejectsToCanje`)</h5>
                    <p><b>Explicación:</b> Esta es la función central de la nueva característica. Cuando la confirmación de un pedido con canje falla, esta función es invocada. Se encarga de: 1) actualizar el estado del pedido a "Rechazado" en la base de datos local; 2) crear una "novedad" para registrar el evento; y 3) enviar una notificación a la API de SML para que el canje de puntos sea revertido, manteniendo así la consistencia entre ambos sistemas.</p>
                    <b>Código Nuevo:</b>
                    <pre><code class="language-javascript">
// DESPUÉS: Se crea la función para manejar la lógica de compensación.
async function sendRejectsToCanje(orderid, internalCode) { 
  // 1. Actualiza el estado del pedido en la colección 'orderModel' a rechazado.
  let fullOrder = await orderModel.findOneAndUpdate({ /* ... */ });
  // 2. Crea una traza y un objeto de rechazo para el sistema de 'news'.
  let trace = { /* ... */ };
  let rejectedExtraDataSave = { /* ... */ };
  // 3. Actualiza el documento de 'news' correspondiente para reflejar el rechazo.
  const result = await news.findOneAndUpdate({ /* ... */ });
  // 4. Crea un nuevo registro en 'orderRejClosed' para notificar al POS.
  await orderRejClosedModel.create({newId : result._id, type: "ordersToSendPOS" });  
  try {       
    // 5. Asegura que el token de SML esté vigente.
    await checkAndRenewToken();  
    // ... (preparación de headers)
    const bodySml = {
      // 6. Construye el payload para la API de SML con los datos del canje.
      "UidCode": fullOrder.order.user.tipoIdentificacion,  
      "UidSerie": fullOrder.order.user.dni,   
      "CardNumber": fullOrder.order.user.numeroTarjetaLoyalty, 
      "IdOrder": orderid, 
      "Points": fullOrder.order.user.puntosCanjeados,  
      "StatusOrder": 2, // Estado de cancelación.
      "PlatformOrder": internalCode === 7 ? "PG" : "I+D"
    };
    // 7. Envía la notificación de cancelación a la API de SML.
    axios.post(`${settings.smlParams.api}/api/UpdateCustomerOrder`, bodySml, headerssml);
  } catch (error) { /* ... */ }
}
                    </code></pre>
                    <h5>4. Lógica de `orderRejClosed`</h5>
                    <p><b>Explicación:</b> Se ha añadido la condición `type: {$exists: false}` a la consulta de la función `orderRejClosed`. Esto permite diferenciar entre los rechazos genéricos que deben ser reenviados a las plataformas y los nuevos rechazos de canje (`type: "ordersToSendPOS"`) que solo deben ser notificados al POS, evitando que el sistema intente procesar estos últimos de forma incorrecta.</p>
                    <b>Código Anterior:</b>
                    <pre><code class="language-javascript">
// ANTES: La consulta procesaba todos los registros con 'send: false'.
const ordersRejClosed = await orderRejClosedModel.find({
  send: false,
  createdAt: { $lt: date2minutes }
});
                    </code></pre>
                    <b>Código Nuevo:</b>
                    <pre><code class="language-javascript">
// DESPUÉS: La consulta ahora excluye los registros que tienen un campo 'type'.
const ordersRejClosed = await orderRejClosedModel.find({
  send: false,
  createdAt: { $lt: date2minutes },
  type: {$exists: false}
});
                    </code></pre>
                    <h5>5. Manejo de Errores en `rejectOrdersPeya`</h5>
                    <p><b>Explicación:</b> La función `rejectOrdersPeya` ha sido modificada para incorporar el nuevo flujo de compensación. Ahora, dentro de los `case` para las plataformas que soportan canjes (como PediGrido e I+D), la llamada a la API de confirmación está envuelta en un `try-catch`. Si la llamada falla, el bloque `catch` verifica si el pedido contenía un canje (`if(fullOrder.order.user.contieneCanje)`) y, de ser así, invoca a `sendRejectsToCanje` para iniciar el proceso de reversión.</p>
                    <b>Código Nuevo:</b>
                    <pre><code class="language-javascript">
// DESPUÉS: Se añade el manejo de errores y la lógica de compensación para canjes.
// ...
case 7: { //'RAPIBOY'
  // ...
  let fullOrder = await orderModel.findOne({ 'originalId': String(reject.orderId) });  
  try {
    await axios.put(reject.url, body, headers);   
  } catch (error) {
    // Si la confirmación falla y el pedido tiene un canje, se llama a la función de compensación.
    if(fullOrder.order.user.contieneCanje)
      await sendRejectsToCanje(reject.orderId, 7); 
    await rejectPeyaModel.findOneAndUpdate({ _id: reject.id }, { send:true });
  }
  break;
}
// ...
                    </code></pre>
                    <h5>6. Integración en el Flujo de Login</h5>
                    <p><b>Explicación:</b> Se ha añadido una llamada a `await SMLLogin()` dentro de la función `login`. Esto asegura que, tan pronto como la aplicación se inicia y la primera sucursal se loguea, el sistema se autentica con SML y obtiene un token válido, preparándolo para cualquier operación que requiera comunicación con el sistema de lealtad.</p>
                    <b>Código Nuevo:</b>
                    <pre><code class="language-javascript">
// DESPUÉS: Se añade la autenticación con SML al flujo de login.
const login = async (req, res) => {  
  // ...
  try {  
    if (!cronAlready) {    
      // ...
      await tokensLoad();
      // Se añade la llamada para obtener el token de SML al inicio.
      await SMLLogin();
      await uberLogin();
      // ...
    } 
  } catch (error) { /* ... */ }    
  // ...
};
                    </code></pre>
                    <div class="analysis-box">
                        <h4>Conclusión del análisis</h4>
                        <p>
                            Este commit introduce una nueva capa de integración con el sistema de lealtad (SML) para manejar rechazos de pedidos que involucran canjes de puntos.
                        </p>
                        <ul>
                            <li><b>Integridad de Datos:</b> El flujo principal se centra en los casos de error durante la confirmación de pedidos. Si un pedido con canje falla, ahora se notifica a SML para cancelar el canje, resolviendo problemas de consistencia y evitando que los clientes pierdan puntos.</li>
                            <li><b>Robustez:</b> La implementación mejora la resiliencia del sistema con un manejo de errores más granular (`try-catch` a nivel de pedido), autenticación automática con renovación de tokens para SML y consultas más precisas.</li>
                            <li><b>Arquitectura Limpia:</b> Los cambios son incrementales y se integran de forma limpia en la lógica existente, añadiendo la nueva funcionalidad sin romper los flujos de trabajo anteriores.</li>
                        </ul>
                    </div>
                </div>
            </details>

            <details class="component-card">
                <summary class="component-header">
                    <h3>api/src/controllers/news.js</h3>
                </summary>
                <div class="component-body">
                    <h4>Análisis General</h4>
                    <p>
                        Esta actualización, como parte de una <strong>Mejora de Filtros de Búsqueda</strong>, refactoriza por completo la función `search` para evolucionar de filtros de valor único a filtros de múltiples valores. El propósito principal de este cambio es dotar a la funcionalidad de búsqueda de novedades de una mayor flexibilidad y potencia, permitiendo a los usuarios seleccionar varios criterios a la vez para una misma categoría (por ejemplo, buscar en varias plataformas o por varios estados de orden simultáneamente).
                    </p>
                    <p>
                        El impacto funcional es significativo: la experiencia de búsqueda se vuelve mucho más rica y eficiente. En lugar de realizar múltiples búsquedas separadas, los usuarios ahora pueden construir consultas complejas en una sola petición. Técnicamente, esto se logra eliminando las conversiones a entero (`parseInt`) para los parámetros de entrada y reemplazando las condiciones de igualdad en las consultas de MongoDB por el operador `$in`, que permite la comparación contra un array de valores.
                    </p>
                    <h4>Cambios Detallados</h4>
                    <h5>1. Eliminación de Conversiones de Tipo</h5>
                    <p><b>Explicación:</b> Se han eliminado las conversiones de tipo (`parseInt`, `toString`) para los parámetros `platform`, `chain` y `status`. Esto se debe a que ahora se espera que estos parámetros puedan ser arrays de valores (ej. `[1, 2, 4]`) en lugar de un único valor.</p>
                    <b>Código Anterior:</b>
                    <pre><code class="language-javascript">
// ANTES: Los parámetros se esperaban como valores únicos y se convertían a tipos específicos.
const search = async (req, res) => {
  // ...
  const platform = parseInt(req.body.platform);
  const chain = req.body.chain?.toString();
  // ...
  const status = parseInt(req.body.status);
  // ...
};
                    </code></pre>
                    <b>Código Nuevo:</b>
                    <pre><code class="language-javascript">
// DESPUÉS: Los parámetros se leen directamente, asumiendo que pueden ser arrays.
const search = async (req, res) => {
  // ...
  const platform = req.body.platform;
  const chain = req.body.chain;
  // ...
  const status = req.body.status;
  // ...
};
                    </code></pre>
                    <h5>2. Lógica para Manejar Filtros de Múltiples Estados</h5>
                    <p><b>Explicación:</b> Se ha introducido una nueva lógica para manejar el parámetro `status` cuando es un array. El código ahora separa los valores de `status` en dos grupos: `types` (que contiene los estados especiales 1 y 10, que filtran por el campo `typeId`) y `orderStatus` (que contiene el resto de los estados, que filtran por `order.statusId`). Esto permite construir una consulta `$or` en MongoDB que busca en ambos campos simultáneamente.</p>
                    <b>Código Nuevo:</b>
                    <pre><code class="language-javascript">
// DESPUÉS: Se introduce una lógica para manejar un array de estados y buscar en múltiples campos.
// ...
  let types = [];
  let orderStatus = [];
  // Si 'status' no está vacío, se procesa.
  if (status != ''){
    // Se separan los valores de 'status' en dos arrays distintos.
    types = status.filter(s => s === 1 || s === 10);
    orderStatus = status.filter(s => s !== 1 && s !== 10);
  }
  const data = {
    // ...
    // Se construye una consulta $or que busca en 'typeId' O en 'order.statusId'.
    ...(status != '' ? { 
        $or: [
          ...(types.length > 0 ? [{ typeId: { $in: types } }] : []),
          ...(orderStatus.length > 0 ? [{ 'order.statusId': { $in: orderStatus } }] : [])
        ]
      } : {}),
    // ...
  };
// ...
                    </code></pre>
                    <h5>3. Reemplazo de Igualdad por el Operador `$in`</h5>
                    <p><b>Explicación:</b> Para soportar los nuevos parámetros de tipo array, todas las condiciones de filtro en la consulta de MongoDB se han modificado. En lugar de una comparación de igualdad directa, ahora se utiliza el operador `$in`. Esto permite que la base de datos busque documentos donde el campo coincida con cualquiera de los valores presentes en el array del filtro.</p>
                    <b>Código Nuevo:</b>
                    <pre><code class="language-javascript">
// DESPUÉS: Los filtros ahora usan el operador '$in' para soportar arrays de valores.
// ...
const data = {
    // ...
    // Busca si 'order.platformId' está en el array 'platform'.
    ...(platform != '' ? { 'order.platformId':{ $in: platform } } : {}),
    // Busca si 'extraData.chain' está en el array 'chain'.
    ...(chain != '' ? { 'extraData.chain': { $in: chain }  } : {}),
    // ...
    // Busca si 'rejectMessageDescription' está en el array 'rejectedMessage'.
    ...(rejectedMessage != '' ? { 'extraData.rejected.rejectMessageDescription': { $in: rejectedMessage }  } : {}),
    // Busca si 'country' está en el array 'country'.
    ...(country != '' ? { 'extraData.country': { $in: country } } : {}),
    // ...
};
// ...
                    </code></pre>
                    <div class="analysis-box">
                        <h4>Conclusión del análisis</h4>
                        <p>
                            La refactorización de la función `search` en `api/src/controllers/news.js` transforma una herramienta de búsqueda simple en una potente funcionalidad de filtrado múltiple.
                        </p>
                        <ul>
                            <li><b>Flexibilidad Mejorada:</b> Los usuarios ya no están limitados a buscar por un solo criterio a la vez para categorías como plataforma, cadena o estado. Ahora pueden realizar consultas complejas como "mostrar órdenes de PedidosYa y Rappi que estén en estado 'Confirmado' o 'Enviado'".</li>
                            <li><b>Experiencia de Usuario:</b> Esta mejora tiene un impacto directo y positivo en la experiencia del usuario del frontend, permitiendo una exploración de datos mucho más rica y eficiente.</li>
                        </ul>
                    </div>
                </div>
            </details>
        </section>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
</body>

</html>
