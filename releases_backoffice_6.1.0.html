<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Notas de Release: Backoffice 6.1.0</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" />
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&family=Fira+Code:wght@400&display=swap');

        :root {
            --bg-color: #f4f7f9;
            --card-bg-color: #ffffff;
            --text-color: #212529;
            --text-muted-color: #6c757d;
            --border-color: #dee2e6;
            --primary-color: #0056b3;
            --analysis-bg: #e6f7ff;
            --analysis-border: #91d5ff;
            --deployment-bg: #f0fdf4;
            --deployment-border: #86efac;
        }

        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            padding: 2em;
            line-height: 1.7;
        }

        .container {
            max-width: 960px;
            margin: 0 auto;
        }

        .main-header {
            background-color: var(--card-bg-color);
            padding: 2em;
            border-radius: 8px;
            border: 1px solid var(--border-color);
            margin-bottom: 2.5em;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);
        }

        .main-header h1 {
            margin: 0 0 0.25em 0;
            font-size: 2.2em;
            color: var(--primary-color);
        }

        .main-header p {
            margin: 0;
            font-size: 1.1em;
            color: var(--text-muted-color);
        }

        .deployment-info-box {
            background-color: var(--deployment-bg);
            border-left: 4px solid var(--deployment-border);
            padding: 1em 1.5em;
            margin-bottom: 2.5em;
            border-radius: 4px;
        }

        .deployment-info-box h4 {
            margin-top: 0;
            font-size: 1.2em;
            color: #166534;
        }

        .deployment-info-box p {
            margin: 0.5em 0 0 0;
            font-family: 'Fira Code', monospace;
            font-size: 0.95em;
        }

        .service-section {
            margin-bottom: 3em;
        }

        .service-section>h2 {
            font-size: 1.8em;
            color: var(--primary-color);
            border-bottom: 2px solid var(--border-color);
            padding-bottom: 0.5em;
            margin-bottom: 1.5em;
        }

        .component-card {
            background-color: var(--card-bg-color);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            margin-bottom: 2em;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);
            overflow: hidden;
        }

        .component-header {
            padding: 1em 1.5em;
            background-color: #fafafa;
            border-bottom: 1px solid var(--border-color);
            cursor: pointer;
            list-style: none;
        }

        .component-header::-webkit-details-marker {
            display: none;
        }

        .component-header h3 {
            margin: 0;
            font-family: 'Fira Code', monospace;
            font-size: 1.2em;
        }

        .component-body {
            padding: 1.5em;
        }

        .component-body h4 {
            margin-top: 1.5em;
            margin-bottom: 0.5em;
            font-size: 1.2em;
            color: #343a40;
        }

        .component-body h5 {
            margin-top: 1.5em;
            margin-bottom: 0.5em;
            font-size: 1.1em;
            font-weight: 700;
        }

        .analysis-box {
            background-color: var(--analysis-bg);
            border-left: 4px solid var(--analysis-border);
            padding: 1em 1.5em;
            margin-top: 1.5em;
            border-radius: 4px;
        }

        .analysis-box h4 {
            margin-top: 0;
            font-size: 1.1em;
            color: var(--primary-color);
        }

        .code-wrapper {
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            overflow: hidden;
            margin: 1em 0;
        }

        .code-header {
            background-color: #e0e0e0;
            padding: 0.5em 1em;
            display: flex;
            align-items: center;
        }

        .dot {
            height: 12px;
            width: 12px;
            border-radius: 50%;
            display: inline-block;
            margin-right: 0.5em;
        }

        .dot.red {
            background-color: #ff5f56;
        }

        .dot.yellow {
            background-color: #ffbd2e;
        }

        .dot.green {
            background-color: #27c93f;
        }

        pre[class*="language-"] {
            padding: 1.2em !important;
            margin: 0 !important;
            border-radius: 0 0 6px 6px;
            font-family: 'Fira Code', monospace !important;
            font-size: 0.9em !important;
            line-height: 1.5 !important;
            border: 1px solid var(--border-color);
            border-top: none;
            white-space: pre-wrap;
            word-break: break-all;
        }
    </style>
</head>

<body>
    <div class="container">
        <header class="main-header">
            <h1>Notas de Release: Backoffice 6.1.0</h1>
            <p>Mejoras en la usabilidad y funcionalidad del dashboard de monitoreo con filtros de selección múltiple.</p>
        </header>

        <div class="deployment-info-box">
            <h4>Información de Despliegue</h4>
            <p><b>Versión:</b> 6.1.0</p>
            <p><b>Fecha de Despliegue:</b> 2025-10-01</p>
            <p><b>Entorno:</b> Producción</p>
            <p><b>Commit:</b> e5e2b1554acb544800b9f06b9078dffb207382f7</p>
        </div>

        <section id="summary" class="service-section">
            <h2>Resumen General</h2>
            <p>
                Este commit representa una mejora significativa en la interfaz de usuario del dashboard de estado de la aplicación Angular. Los cambios principales se centran en transformar los filtros de selección única en sistemas de **selección múltiple**, permitiendo a los usuarios filtrar datos por múltiples criterios simultáneamente (estados, motivos de rechazo, plataformas, países y cadenas). Esto se logra mediante la refactorización de los componentes HTML y TypeScript, reemplazando selectores simples con menús desplegables basados en checkboxes, y actualizando la lógica de backend para manejar arrays en lugar de valores únicos.
            </p>
            <p>
                Además, se incorporan dependencias nuevas como **Popper.js** (para compatibilidad con Bootstrap) y **querystring** (para manipulación de URLs), junto con ajustes en la configuración de Angular para incluir estos scripts. Los estilos CSS se actualizan para mejorar la presentación de los nuevos dropdowns.
            </p>
            <p>
                El impacto general es una experiencia de usuario más **flexible y poderosa** en el módulo de monitoreo de estados, facilitando consultas más precisas y complejas sin comprometer la usabilidad. Los cambios son coherentes y no introducen rupturas en la funcionalidad existente, manteniendo la compatibilidad con el resto del sistema.
            </p>
        </section>

        <section id="technical-analysis" class="service-section">
            <h2>Análisis Técnico Detallado</h2>
           <details class="component-card">
                <summary class="component-header">
                    <h3>app/src/app/pages/dashboard/status/status.component.css</h3>
                </summary>
                <div class="component-body">
                    <h4>Análisis General</h4>
                    <p>
                        Esta modificación en la hoja de estilos, como parte de la iniciativa de **Filtros de Selección Múltiple en Dashboard Status**, tiene como propósito mejorar la presentación visual y la usabilidad de los nuevos menús desplegables (`.dropdown-menu`) que fueron introducidos en `status.component.html`. Los cambios de estilo aseguran que los dropdowns se ajusten al ancho del botón que los activa y que su contenido sea navegable a través de un scroll vertical si la lista de opciones es muy larga, evitando problemas de desbordamiento en la interfaz.
                    </p>
                    <h4>Cambios Detallados</h4>
                    <h5>1. Estilos para la Clase `.dropdown-menu`</h5>
                    <p><b>Explicación:</b> Se añadió un nuevo bloque de reglas CSS para la clase `.dropdown-menu`.</p>
                    <ul>
                        <li>`min-width: 100% !important;`: Esta regla fuerza al menú desplegable a tener como mínimo el 100% del ancho de su elemento padre (en este caso, el `div` del dropdown). Esto asegura que el menú se alinee perfectamente con el botón que lo activa, creando una apariencia limpia y organizada. El `!important` se usa para sobreescribir cualquier estilo de Bootstrap u otra hoja de estilos que pueda estar en conflicto.</li>
                        <li>`max-height: 20rem;`: Se establece una altura máxima para el menú desplegable (aproximadamente 320px, asumiendo 1rem = 16px).</li>
                        <li>`overflow-y: auto;`: Esta regla es clave. Si el contenido del dropdown (la lista de checkboxes) excede la `max-height` definida, aparecerá automáticamente una barra de scroll vertical. Esto previene que el menú se extienda indefinidamente y desborde la pantalla, mejorando significativamente la experiencia de usuario en casos con muchas opciones de filtro.</li>
                    </ul>
                    <b>Código Anterior:</b>
                    <div class="code-wrapper">
                        <div class="code-header">
                            <span class="dot red"></span>
                            <span class="dot yellow"></span>
                            <span class="dot green"></span>
                        </div>
                        <pre><code class="language-css">
// ANTES: No existían estilos específicos para .dropdown-menu en este archivo.
table td {
  width: 30px;
  height: 48px;
}
                        </code></pre>
                    </div>
                    <b>Código Nuevo:</b>
                    <div class="code-wrapper">
                        <div class="code-header">
                            <span class="dot red"></span>
                            <span class="dot yellow"></span>
                            <span class="dot green"></span>
                        </div>
                        <pre><code class="language-css">
// DESPUÉS: Nuevos estilos para los menús desplegables.
table td {
  width: 30px;
  height: 48px;
}
.dropdown-menu {
  min-width: 100% !important; // DESPUÉS: Asegura que el dropdown ocupe todo el ancho del botón.
  max-height: 20rem; /* ~320px */ // DESPUÉS: Limita la altura del dropdown.
  overflow-y: auto; // DESPUÉS: Añade una barra de scroll vertical si el contenido excede la altura máxima.
}
                        </code></pre>
                    </div>
                    <div class="analysis-box">
                        <h4>Conclusión del Análisis</h4>
                        <p>
                            La actualización en `status.component.css` es un complemento esencial para la nueva funcionalidad de filtros de selección múltiple.
                        </p>
                        <ul>
                            <li><b>Mejora Visual:</b> Al asegurar que el ancho del dropdown coincida con el del botón, se logra una apariencia más pulida y profesional.</li>
                            <li><b>Usabilidad Mejorada:</b> La combinación de `max-height` y `overflow-y: auto` es crucial para la usabilidad. Previene que listas largas de opciones (por ejemplo, en un sistema con muchos países o plataformas) rompan el layout de la página, manteniendo la interfaz contenida y accesible.</li>
                            <li><b>Escalabilidad del Diseño:</b> El diseño ahora está preparado para manejar un número creciente de opciones de filtro sin comprometer la integridad visual de la página.</li>
                        </ul>
                        <p>
                            En conjunto, estos estilos son un detalle técnico importante que asegura que la nueva funcionalidad no solo sea potente, sino también visualmente coherente y robusta.
                        </p>
                    </div>
                </div>
            </details>
            <details class="component-card">
                <summary class="component-header">
                    <h3>app/src/app/pages/dashboard/status/status.component.ts</h3>
                </summary>
                <div class="component-body">
                    <h4>Análisis General</h4>
                    <p>
                        Este archivo de lógica es el núcleo de la nueva funcionalidad de selección múltiple. Como parte de la iniciativa de **Filtros de Selección Múltiple en Dashboard Status**, este componente se ha refactorizado para soportar la lógica detrás de los nuevos `dropdowns` con checkboxes, transformando cómo los filtros son gestionados y enviados al backend. El impacto principal es una reestructuración del estado del componente, pasando de propiedades de filtro de valor único (ej: `platform: number`) a arrays que almacenan los objetos seleccionados (`selectedPlatforms: any[]`). Se introduce un método central `onCheckboxChange` para manejar todas las interacciones de selección y se adapta la construcción de la petición al backend para que envíe arrays de IDs o nombres en lugar de un único valor, habilitando así consultas mucho más potentes.
                    </p>
                    <h4>Cambios Detallados</h4>
                    <h5>1. Refactorización de Propiedades de Filtro a Arrays de Selección Múltiple</h5>
                    <p><b>Explicación:</b> Se han eliminado las propiedades que antes almacenaban un único valor de filtro (como `platform`, `chain`, `searchStatus`, `rejectedMessage` y `country`). En su lugar, se han añadido nuevos arrays para cada filtro (`selectedStates`, `selectedRej`, `selectedPlatforms`, `selectedCountries`, `selectedChains`) que almacenarán los **objetos completos** seleccionados por el usuario. Además, se introdujeron propiedades de tipo `string` (`newStatesspName`, `rejectedMesagesName`, etc.) para controlar el texto que se muestra en el botón del `dropdown`, proporcionando feedback visual al usuario sobre su selección.</p>
                    <b>Código Anterior:</b>
                    <div class="code-wrapper">
                        <div class="code-header">
                            <span class="dot red"></span>
                            <span class="dot yellow"></span>
                            <span class="dot green"></span>
                        </div>
                        <pre><code class="language-javascript">
public countries: Country[] = [];
public country = ""; // ANTES: Almacenaba un único valor de país.
// ...
public rejectedMesages: RejectedMessage[] = [];
// ...
public search: string = "";
public platform: number = 0; // ANTES: Almacenaba un único ID de plataforma.
public chain: number = 0; // ANTES: Almacenaba un único ID de cadena.
public searchStatus: number = 0; // ANTES: Almacenaba un único ID de estado.
// ...
public rejectedMessage: string = ""; // ANTES: Almacenaba un único mensaje de rechazo.
                        </code></pre>
                    </div>
                    <b>Código Nuevo:</b>
                    <div class="code-wrapper">
                        <div class="code-header">
                            <span class="dot red"></span>
                            <span class="dot yellow"></span>
                            <span class="dot green"></span>
                        </div>
                        <pre><code class="language-javascript">
public countries: Country[] = [];
// public country = ""; // DESPUÉS: Eliminada.
// ...
public rejectedMesages: any[] = []; // DESPUÉS: Tipo cambiado a 'any[]' para mayor flexibilidad.
public selectedStates: any[] = []; // DESPUÉS: Nuevo array para los estados seleccionados.
public selectedRej: any[] = []; // DESPUÉS: Nuevo array para los motivos de rechazo seleccionados.
public selectedPlatforms: any[] = []; // DESPUÉS: Nuevo array para las plataformas seleccionadas.
public selectedCountries: any[] = []; // DESPUÉS: Nuevo array para los países seleccionados.
public selectedChains: any[] = []; // DESPUÉS: Nuevo array para las cadenas seleccionadas.
public newStatesspName = "Todos los Estados"; // DESPUÉS: Texto para el botón del dropdown de estados.
public rejectedMesagesName = "Todos los Motivos de Rechazo"; // DESPUÉS: Texto para el botón del dropdown de motivos de rechazo.
public platformName = "Todas las Plataformas"; // DESPUÉS: Texto para el botón del dropdown de plataformas.
public countryName = "Todos los Paises"; // DESPUÉS: Texto para el botón del dropdown de países.
public chainsName = "Todas las Cadenas"; // DESPUÉS: Texto para el botón del dropdown de cadenas.
public search: string = "";
// public platform: number = 0; // DESPUÉS: Eliminada.
// public chain: number = 0; // DESPUÉS: Eliminada.
// public searchStatus: number = 0; // DESPUÉS: Eliminada.
// ...
// public rejectedMessage: string = ""; // DESPUÉS: Eliminada.
                        </code></pre>
                    </div>
                    <h5>2. Modificación de `ngOnInit`</h5>
                    <p><b>Explicación:</b> La lógica en `ngOnInit` se ha adaptado para la selección múltiple. Después de obtener los datos para cada filtro (países, estados, cadenas, etc.), se añade una opción "Todos" al principio de cada lista (`unshift`). Luego, el array de selección correspondiente (`selectedCountries`, `selectedStates`, etc.) se inicializa con una copia completa de la lista de opciones, lo que asegura que por defecto el filtro "Todos" esté seleccionado y activo.</p>
                    <b>Código Anterior:</b>
                    <div class="code-wrapper">
                        <div class="code-header">
                            <span class="dot red"></span>
                            <span class="dot yellow"></span>
                            <span class="dot green"></span>
                        </div>
                        <pre><code class="language-javascript">
this._countriesService.getCountries().subscribe((result) => {
this.countries = result;
resolve();
});
                        </code></pre>
                    </div>
                    <b>Código Nuevo:</b>
                    <div class="code-wrapper">
                        <div class="code-header">
                            <span class="dot red"></span>
                            <span class="dot yellow"></span>
                            <span class="dot green"></span>
                        </div>
                        <pre><code class="language-javascript">
this._countriesService.getCountries().subscribe((result) => {
this.countries = result;
let country = new Country;
country.country="Todos los Paises";
this.countries.unshift(country); // DESPUÉS: Añade una opción "Todos" al principio de la lista.
this.selectedCountries = Array.from(this.countries); // DESPUÉS: Inicializa el array de selección con todos los países.
resolve();
});
// (Este patrón se repite para 'newStates', 'chains', 'platforms' y 'rejectedMesages')
                        </code></pre>
                    </div>
                    <h5>3. Nuevo Método Central `onCheckboxChange`</h5>
                    <p><b>Explicación:</b> Se ha añadido un nuevo método `onCheckboxChange(event, item, change)`. Este método es el manejador de eventos para todos los checkboxes de los nuevos `dropdowns`. Utiliza un `switch` basado en el parámetro `change` ('States', 'Rejs', 'Platforms', etc.) para direccionar la lógica al array de selección correcto. Su función principal es añadir o quitar elementos del array de selección basándose en si el checkbox está marcado o desmarcado. Además, incluye una lógica especial para la opción "Todos": si se marca, selecciona todos los elementos; si se desmarca, deselecciona todos. También deselecciona la opción "Todos" si se desmarca cualquier otra opción individual.</p>
                    <b>Código Nuevo:</b>
                    <div class="code-wrapper">
                        <div class="code-header">
                            <span class="dot red"></span>
                            <span class="dot yellow"></span>
                            <span class="dot green"></span>
                        </div>
                        <pre><code class="language-javascript">
onCheckboxChange(event: any, item: any, change: string) {
switch (change) {
case "States": // DESPUÉS: Lógica para el filtro de estados.
if (event.target.checked) {
if(item.spName === "Todos los Estados") { // DESPUÉS: Si se marca "Todos", selecciona todo.
this.selectedStates = Array.from(this.newStates);
this.newStatesspName = "Todos los Estados";
}
else {
this.selectedStates.push(item);
}
} else {
if(item.spName === "Todos los Estados"){ // DESPUÉS: Si se desmarca "Todos", deselecciona todo.
this.selectedStates = Array.from([]);
this.newStatesspName = "Estados Seleccionados";
}
else {
this.selectedStates = this.selectedStates.filter(i => i !== item); // DESPUÉS: Quita el elemento de la selección.
if(this.selectedStates.find(r => r.spName === "Todos los Estados")) { // DESPUÉS: Si "Todos" estaba marcado, lo desmarca.
this.selectedStates = this.selectedStates.filter(i => i.spName !== "Todos los Estados");
this.newStatesspName = "Estados Seleccionados";
}
}
break;
// (Este patrón se repite para 'Rejs', 'Platforms', 'Countries' y 'Chains')
}
}
                        </code></pre>
                    </div>
                    <h5>4. Refactorización del Método `generateNewsDashboard`</h5>
                    <p><b>Explicación:</b> El método `generateNewsDashboard`, que prepara los datos para la petición al backend, ha sido modificado significativamente. En lugar de enviar valores únicos para los filtros, ahora se comprueba si la opción "Todos" está seleccionada (comparando el `...Name` con el texto "Todos..."). Si es así, se envía una cadena vacía (lo que indica al backend que no filtre por ese campo). Si no, se utiliza `map()` sobre el array de selección correspondiente (`selectedPlatforms`, `selectedChains`, etc.) para extraer solo la propiedad necesaria (ej. `item.internalCode`, `item.chain`, `item.stateId`) y se envía este array de valores al backend.</p>
                    <b>Código Anterior:</b>
                    <div class="code-wrapper">
                        <div class="code-header">
                            <span class="dot red"></span>
                            <span class="dot yellow"></span>
                            <span class="dot green"></span>
                        </div>
                        <pre><code class="language-javascript">
let data = {
search: this.search,
platform: this.platform,
chain: this.chain,
status: this.searchStatus,
branch: this.searchBranch,
order: this.order,
page: this.page,
cloudBoolean: this.cloudBoolean,
rejectedMessage: this.rejectedMessage !== "0" ? this.rejectedMessage : "",
country: this.country,
dateSelected: this.dateSelected,
searchSKU: this.searchSKU,
turboBoolean: this.turboBoolean
};
                        </code></pre>
                    </div>
                    <b>Código Nuevo:</b>
                    <div class="code-wrapper">
                        <div class="code-header">
                            <span class="dot red"></span>
                            <span class="dot yellow"></span>
                            <span class="dot green"></span>
                        </div>
                        <pre><code class="language-javascript">
let data = {
search: this.search,
platform: this.platformName === "Todas las Plataformas" ? '' : this.selectedPlatforms.map(item => item.internalCode), // DESPUÉS: Envía un array de internalCodes o una cadena vacía.
chain: this.chainsName === "Todas las Cadenas" ? '' : this.selectedChains.map(item => item.chain), // DESPUÉS: Envía un array de nombres de cadenas o una cadena vacía.
status: this.newStatesspName === "Todos los Estados" ? '' : this.selectedStates.map(item => item.stateId), // DESPUÉS: Envía un array de stateIds o una cadena vacía.
branch: this.searchBranch,
order: this.order,
page: this.page,
cloudBoolean: this.cloudBoolean,
rejectedMessage: this.rejectedMesagesName === "Todos los Motivos de Rechazo" ? '' : this.selectedRej, // DESPUÉS: Envía un array de mensajes de rechazo o una cadena vacía.
country: this.countryName === "Todos los Paises" ? '' : this.selectedCountries.map(item => item.country), // DESPUÉS: Envía un array de nombres de países o una cadena vacía.
dateSelected: this.dateSelected,
searchSKU: this.searchSKU,
turboBoolean: this.turboBoolean
};
                        </code></pre>
                    </div>
                    <div class="analysis-box">
                        <h4>Conclusión del análisis</h4>
                        <p>
                            La actualización de `status.component.ts` es el complemento lógico indispensable para los cambios en la interfaz de usuario. Transforma la gestión del estado del componente para soportar completamente la funcionalidad de selección múltiple.
                        </p>
                        <ul>
                            <li><b>Estado de Componente Robusto:</b> El cambio de propiedades de valor único a arrays (`selected...`) y propiedades de display (`...Name`) crea un sistema de estado claro y robusto para gestionar las selecciones complejas del usuario.</li>
                            <li><b>Lógica de Selección Centralizada:</b> El método `onCheckboxChange` centraliza la lógica de interacción con los checkboxes, incluyendo el manejo del caso especial "Todos", lo que reduce la duplicación de código y simplifica el mantenimiento.</li>
                            <li><b>Adaptación al Backend:</b> El método `generateNewsDashboard` se adapta inteligentemente para transformar los arrays de objetos seleccionados en el frontend a los arrays de valores primitivos (IDs o nombres) que el backend espera, asegurando una comunicación correcta con la API.</li>
                        </ul>
                        <p>
                            En resumen, estos cambios en el TypeScript son el motor que habilita la potente y flexible experiencia de filtrado introducida en el HTML, completando la implementación de la nueva funcionalidad.
                        </p>
                    </div>
                </div>
            </details>
 <details class="component-card">
                <summary class="component-header">
                    <h3>app/src/app/pages/dashboard/status/status.component.html</h3>
                </summary>
                <div class="component-body">
                    <h4>Análisis General</h4>
                    <p>
                        Esta modificación representa una refactorización significativa de la sección de filtros de "Pedidos Entrantes". Como parte de la iniciativa de **Filtros de Selección Múltiple en Dashboard Status**, el cambio principal es reemplazar varios selectores (`<select>`) de selección única por menús desplegables (dropdown) basados en checkboxes (`<input type="checkbox">`), lo que transforma la experiencia de usuario y la capacidad de filtrado. Esta actualización permite a los operadores seleccionar múltiples valores para los filtros de "Estado", "Motivo de Rechazo", "Plataforma", "País" y "Cadena", en lugar de estar limitados a una sola opción, permitiendo consultas mucho más flexibles y potentes.
                    </p>
                    <h4>Cambios Detallados</h4>
                    <h5>1. Reemplazo de Selector de Estados por Dropdown de Checkboxes</h5>
                    <p><b>Explicación:</b> El `<select>` para filtrar por `searchStatus` fue eliminado y reemplazado por un `dropdown` de Bootstrap. Este `dropdown` muestra un botón con el nombre del estado o estados seleccionados (`newStatesspName`) y, al abrirse, revela una lista de checkboxes, uno por cada estado disponible. La lógica de selección múltiple se gestiona a través del método `onCheckboxChange`, que se activa al interactuar con cada checkbox.</p>
                    <b>Código Anterior:</b>
                    <div class="code-wrapper">
                        <div class="code-header">
                            <span class="dot red"></span>
                            <span class="dot yellow"></span>
                            <span class="dot green"></span>
                        </div>
                        <pre><code class="language-html">
// ANTES: Un selector simple con una sola opción posible.
&lt;div class="form-group col-md-2">
&lt;select class="form-control form-control-sm" [(ngModel)]="searchStatus">
&lt;option value="0">Todos los Estados&lt;/option>
&lt;option *ngFor="let newState of newStates; index as i" [value]="newState.stateId">
{{ newState.spName }}
&lt;/option>
&lt;/select>
&lt;/div>
                        </code></pre>
                    </div>
                    <b>Código Nuevo:</b>
                    <div class="code-wrapper">
                        <div class="code-header">
                            <span class="dot red"></span>
                            <span class="dot yellow"></span>
                            <span class="dot green"></span>
                        </div>
                        <pre><code class="language-html">
// DESPUÉS: Un dropdown que permite selección múltiple.
&lt;div class="col 12 form-group dropdown col-md-2 d-flex justify-content-start">
&lt;button class="btn border dropdown-toggle d-flex justify-content-between align-items-center w-100" type="button" data-toggle="dropdown">
&lt;span>{{newStatesspName}}&lt;/span> // DESPUÉS: Muestra el nombre del/los estado(s) seleccionado(s).
&lt;/button>
&lt;div class="dropdown-menu dropdown-menu-right" (click)="$event.stopPropagation()">
&lt;div *ngFor="let newState of newStates; let i = index" class="form-check">
&lt;input
class="form-check-input"
type="checkbox"
[id]="'state' + i"
[value]="newState"
(change)="onCheckboxChange($event, newState, 'States')" // DESPUÉS: Llama a la función de manejo de selección.
[checked]="selectedStates.includes(newState)"/> // DESPUÉS: El estado del checkbox se basa en el array de selección.
&lt;label *ngIf="newState.spName !== 'Todos los Estados'" class="form-check-label" [for]="'state' + i">
{{ newState.spName }}
&lt;/label>
&lt;label *ngIf="newState.spName === 'Todos los Estados'" class="form-check-label" [for]="'state' + i">
&lt;b>{{ newState.spName }}&lt;/b>
&lt;/label>
&lt;/div>
&lt;/div>
&lt;/div>
                        </code></pre>
                    </div>
                    <h5>2. Reemplazo de Selectores de Motivos, Plataformas, Países y Cadenas por Dropdowns de Checkboxes</h5>
                    <p><b>Explicación:</b> Siguiendo el mismo patrón que con los "Estados", los `<select>` para `rejectedMessage`, `platform`, `country` y `chain` fueron reemplazados por `dropdowns` de Bootstrap con checkboxes. Cada `dropdown` está asociado a su propio array de selección en el componente (`selectedRej`, `selectedPlatforms`, `selectedCountries`, `selectedChains`) y a una propiedad de nombre para el botón (`rejectedMesagesName`, `platformName`, `countryName`, `chainsName`). Esta estructura se repite para cada uno de estos filtros, transformando su funcionalidad de selección única a múltiple.</p>
                    <b>Código Nuevo:</b>
                    <div class="code-wrapper">
                        <div class="code-header">
                            <span class="dot red"></span>
                            <span class="dot yellow"></span>
                            <span class="dot green"></span>
                        </div>
                        <pre><code class="language-html">
// DESPUÉS: Dropdowns de checkboxes para cada filtro.
&lt;div class="form-group dropdown col-12 col-md-2 d-flex justify-content-start">
&lt;button class="btn border dropdown-toggle d-flex justify-content-between align-items-center w-100" type="button" data-toggle="dropdown">
&lt;span>{{rejectedMesagesName}}&lt;/span>
&lt;/button>
&lt;div class="dropdown-menu dropdown-menu-right" (click)="$event.stopPropagation()">
&lt;div *ngFor="let row of rejectedMesages; index as i" class="form-check">
&lt;input
class="form-check-input"
type="checkbox"
(change)="onCheckboxChange($event, row, 'Rejs')"
[checked]="selectedRej.includes(row)"/>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="form-group dropdown col-12 col-md-2 d-flex justify-content-start">
&lt;button class="btn border dropdown-toggle d-flex justify-content-between align-items-center w-100" type="button" data-toggle="dropdown">
&lt;span>{{platformName}}&lt;/span>
&lt;/button>
&lt;div class="dropdown-menu dropdown-menu-right" (click)="$event.stopPropagation()">
&lt;div *ngFor="let platform of platforms; index as i" class="form-check">
&lt;input
class="form-check-input"
type="checkbox"
(change)="onCheckboxChange($event, platform, 'Platforms')"
[checked]="selectedPlatforms.includes(platform)"/>
&lt;/div>
&lt;/div>
&lt;/div>
                        </code></pre>
                    </div>
                    <h5>3. Reorganización del Layout de Filtros en Filas</h5>
                    <p><b>Explicación:</b> La estructura del HTML para los filtros se reorganizó, moviendo los selectores de "Orden", "Cloud", "Turbo", el nuevo filtro de "Cadena" y el botón "Actualizar" a una segunda fila (`<div class="row">`). Esto mejora la legibilidad y la organización visual de la interfaz, agrupando los filtros de selección múltiple en una fila y los de selección simple y acciones en otra.</p>
                    <b>Código Nuevo:</b>
                    <div class="code-wrapper">
                        <div class="code-header">
                            <span class="dot red"></span>
                            <span class="dot yellow"></span>
                            <span class="dot green"></span>
                        </div>
                        <pre><code class="language-html">
// DESPUÉS: Los filtros se dividen en dos filas.
&lt;div class="row">
&lt;/div>
&lt;div class="row">
&lt;/div>
                        </code></pre>
                    </div>
                    <h5>4. Corrección de Texto en Selectores de "Cloud" y "Turbo"</h5>
                    <p><b>Explicación:</b> El texto de la opción `value="all"` en los `select` de `cloudBoolean` y `turboBoolean` se revirtió de "Cloud/No Cloud" y "Turbo/No Turbo" a "Todas las sucursales". Este es un **bug fix** de usabilidad, probablemente para restaurar un texto más genérico y consistente con el resto de la aplicación.</p>
                    <b>Código Nuevo:</b>
                    <div class="code-wrapper">
                        <div class="code-header">
                            <span class="dot red"></span>
                            <span class="dot yellow"></span>
                            <span class="dot green"></span>
                        </div>
                        <pre><code class="language-html">
// DESPUÉS: Texto genérico para la opción "todos".
&lt;option value="all">Todas las sucursales&lt;/option>
...
&lt;option value="all">Todas las sucursales&lt;/option>
                        </code></pre>
                    </div>
                    <div class="analysis-box">
                        <h4>Conclusión del análisis</h4>
                        <p>
                            La actualización de `status.component.html` transforma radicalmente la experiencia de filtrado en el Dashboard Status, haciéndola significativamente más potente y flexible.
                        </p>
                        <ul>
                            <li><b>Selección Múltiple:</b> El cambio de `<select>` a `dropdowns` con checkboxes es la modificación clave, permitiendo a los usuarios realizar consultas complejas y segmentar los datos de manera mucho más precisa que antes.</li>
                            <li><b>Mejora de la Experiencia de Usuario:</b> La nueva interfaz, aunque más compleja en su implementación, proporciona un control más intuitivo para la selección de múltiples valores, con el nombre de los filtros seleccionados visible en el botón del `dropdown`.</li>
                            <li><b>Escalabilidad:</b> Esta estructura de `dropdowns` es más escalable para futuras adiciones de opciones de filtrado.</li>
                            <li><b>Preparación para la Lógica del Componente:</b> Estos cambios en la plantilla HTML son el primer paso y preparan el terreno para las modificaciones correspondientes en el archivo TypeScript (`status.component.ts`), donde se implementará la lógica para manejar los arrays de selección múltiple.</li>
                        </ul>
                    </div>
                </div>
            </details>


        </section>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
</body>

</html>
