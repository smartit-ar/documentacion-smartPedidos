<!DOCTYPE html>
<html lang="es">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Release Técnico: Platform 8.3.0</title>
  
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" />
  
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&family=Fira+Code:wght@400&display=swap');

    :root {
      --bg-color: #f4f7f9;
      --card-bg-color: #ffffff;
      --text-color: #212529;
      --text-muted-color: #6c757d;
      --border-color: #dee2e6;
      --primary-color: #0056b3;
      --analysis-bg: #e6f7ff;
      --analysis-border: #91d5ff;
      --deployment-bg: #f0fdf4;
      --deployment-border: #86efac;
    }

    body {
      font-family: 'Inter', sans-serif;
      background-color: var(--bg-color);
      color: var(--text-color);
      margin: 0;
      padding: 2em;
      line-height: 1.7;
    }

    .container {
      max-width: 960px;
      margin: 0 auto;
    }
    
    .main-header {
      background-color: var(--card-bg-color);
      padding: 2em;
      border-radius: 8px;
      border: 1px solid var(--border-color);
      margin-bottom: 2.5em;
      box-shadow: 0 4px 12px rgba(0,0,0,0.05);
    }
    
    .main-header h1 {
      margin: 0 0 0.25em 0;
      font-size: 2.2em;
      color: var(--primary-color);
    }
    
    .main-header p {
      margin: 0;
      font-size: 1.1em;
      color: var(--text-muted-color);
    }

    .deployment-info-box {
      background-color: var(--analysis-bg);
      border-left: 4px solid var(--analysis-border);
      padding: 1em 1.5em;
      margin-bottom: 2.5em;
      border-radius: 4px;
    }
    .deployment-info-box h4 {
      margin-top: 0;
      font-size: 1.2em;
      color: #166534;
    }
    .deployment-info-box p {
      margin: 0.5em 0 0 0;
      font-family: 'Fira Code', monospace;
      font-size: 0.95em;
    }

    .service-section {
        margin-bottom: 3em;
    }

    .service-section > h2 {
        font-size: 1.8em;
        color: var(--primary-color);
        border-bottom: 2px solid var(--border-color);
        padding-bottom: 0.5em;
        margin-bottom: 1.5em;
    }
    
    .component-card {
      background-color: var(--card-bg-color);
      border: 1px solid var(--border-color);
      border-radius: 8px;
      margin-bottom: 2em;
      box-shadow: 0 4px 12px rgba(0,0,0,0.05);
      overflow: hidden;
    }
    
    .component-header {
      padding: 1em 1.5em;
      background-color: #fafafa;
      border-bottom: 1px solid var(--border-color);
      cursor: pointer;
      list-style: none;
    }

    .component-header::-webkit-details-marker {
      display: none;
    }
    
    .component-header h3 {
      margin: 0;
      font-family: 'Fira Code', monospace;
      font-size: 1.2em;
    }

    .component-body {
      padding: 1.5em;
    }

    .component-body h4 {
        margin-top: 1.5em;
        margin-bottom: 0.5em;
        font-size: 1.2em;
        color: #343a40;
    }
    
    .component-body h5 {
        margin-top: 1.5em;
        margin-bottom: 0.5em;
        font-size: 1.1em;
        font-weight: 700;
    }
    
    .analysis-box {
      background-color: var(--analysis-bg);
      border-left: 4px solid var(--analysis-border);
      padding: 1em 1.5em;
      margin-top: 1.5em;
      border-radius: 4px;
    }
    
    .analysis-box h4 {
      margin-top: 0;
      font-size: 1.1em;
      color: var(--primary-color);
    }

    pre[class*="language-"] {
      padding: 1.2em !important;
      margin: 1em 0 !important;
      border-radius: 6px;
      font-family: 'Fira Code', monospace !important;
      font-size: 0.9em !important;
      line-height: 1.5 !important;
      border: 1px solid var(--border-color);
      white-space: pre-wrap;
      word-break: break-all;
    }
  </style>
</head>

<body>

  <div class="container">
    <header class="main-header">
      <h1>Notas de Release: Platform 8.3.0</h1>
      <p>Refactorización del Flujo de Autenticación de MercadoPago y Mejoras de Seguridad</p>
    </header>

    <div class="deployment-info-box">
        <h4>Información de Despliegue</h4>
        <p><b>Versión:</b> 8.3.0</p>
        <p><b>Fecha de Despliegue:</b> 2025-09-01</p>
        <p><b>Entorno:</b> Producción</p>
        <p><b>AWS TASK:</b> 166</p>
        <p><b>COMMIT:</b> a057db0915edf231d26169134a7f54e3e0f501a3</p>
    </div>

    <section id="summary" class="service-section">
        <h2>Resumen General</h2>
        <p>
            El commit <code>a057db0915edf231d26169134a7f54e3e0f501a3</code> representa una refactorización en la forma en que el platform se autentica con la API de MercadoPago.
        </p>
        <p><b>Antes del cambio:</b> Se dependía de tokens almacenados en la base de datos, asociados a cada sucursal o cliente (<code>mercadoPagoClientModel</code>), y el código para usarlos estaba distribuido entre los controladores y las clases de la plataforma.</p>
        <p><b>Después del cambio (Puntos Clave):</b></p>
        <ol>
            <li>
                <b>Centralización de la Autenticación:</b> Se introduce un nuevo servicio (<code>utils/token.js</code>). Este servicio es ahora el único responsable de comunicarse con el Cloud para obtener y renovar los tokens de API.
            </li>
            <li>
                <b>Flujo de Múltiples Pasos:</b> Para interactuar con MercadoPago, ahora sigue un flujo más seguro y robusto:
                <ol type="a" style="padding-left: 20px;">
                    <li>Obtiene un token genérico del servicio en el Cloud.</li>
                    <li>Usa ese token para solicitar un segundo token, específico para la cuenta de MercadoPago (<code>user_id</code>), que se obtiene de la orden.</li>
                    <li>Este segundo token viene encriptado y es desencriptado por el utilitario <code>Token</code>.</li>
                    <li>Finalmente, el token desencriptado se usa para realizar la operación deseada (aceptar o rechazar una orden).</li>
                </ol>
            </li>
            <li>
                <b>Mejora en la Seguridad y Mantenibilidad:</b>
                <ul style="padding-left: 20px;">
                    <li>Se eliminan los tokens de larga duración de la base de datos, lo que reduce la superficie de ataque.</li>
                    <li>La lógica de autenticación y desencriptación está ahora en un solo lugar, facilitando futuras actualizaciones.</li>
                    <li>Se ha añadido un sistema de logging mucho más detallado en todo el flujo.</li>
                </ul>
            </li>
        </ol>
        <p>
            <b>En resumen</b>, este commit mejora la integración con MercadoPago, haciéndola más segura, robusta y mantenible.
        </p>
    </section>

    <section id="service-one" class="service-section">
      <h2>Análisis Técnico Detallado</h2>

      <details class="component-card">
        <summary class="component-header">
          <h3>api/src/controllers/mercadoPago.js</h3>
        </summary>
        <div class="component-body">
            <h4>Análisis General</h4>
            <p>
              Este commit representa una <b>refactorización</b> en la forma en que el sistema se autentica para procesar las notificaciones de MercadoPago. Se abandona el modelo anterior de almacenar tokens por cliente (<code>mercadoPagoClientModel</code>) en favor de un <b>flujo de obtención de tokens centralizado y en tiempo real</b> que involucra al Cloud y un módulo de encriptación.
            </p>
            <p>
              El objetivo principal es mejorar la seguridad y la gestión de los tokens de acceso, delegando su obtención y desencriptación al Cloud, y añadiendo capas de validación y registro de errores para hacer el proceso más robusto.
            </p>
            
            <h4>Cambios Detallados</h4>
    
            <h5>1. Reemplazo de Dependencias y Lógica de Autenticación</h5>
            <p><b>Explicación:</b> Se elimina la dependencia del modelo <code>mercadoPagoClientModel</code> y se introduce una nueva utilidad, <code>Token</code>.
            <b>Código Anterior:</b>
            <pre><code class="language-javascript">
    // ...
    import branchModel from '../models/branch';
    import mercadoPagoClientModel from '../models/mercadoPagoClient'; // <-- ANTES: Se usaba este modelo para buscar tokens.
    import mongoose from 'mongoose';
    import config from '../config/settings';
    // ...
            </code></pre>
            <b>Código Nuevo:</b>
            <pre><code class="language-javascript">
    // ...
    import branchModel from '../models/branch';
    import mongoose from 'mongoose';
    import config from '../config/settings';
    import Token from '../utils/token'; // <-- DESPUÉS: Se importa la nueva utilidad para obtener y desencriptar tokens.
    // ...
            </code></pre>
    
            <h5>2. Nuevo Flujo de Obtención y Desencriptación de Tokens</h5>
            <p><b>Explicación:</b> La lógica para obtener el token de autorización de MercadoPago ahora sigue un proceso de pasos que involucra al Cloud.</p>
            <b>Código Anterior:</b>
            <pre><code class="language-javascript">
    // ANTES: El token se obtenía directamente de la base de datos buscando por el user_id.
    let mercadoPagoClient = await mercadoPagoClientModel.findOne({ user_id: req.body.user_id })
    if (!mercadoPagoClient) {
      Log.saveError(null, { message: 'MercadoPago client not found', /*...*/ });        
      return res.status(404).json({ message: 'MercadoPago client not found' });
    }
    // ...
    const headersConfig = {
      headers: {
        'Authorization': `Bearer ${mercadoPagoClient.token}`
      }
    };
    // ...
            </code></pre>
            <b>Código Nuevo:</b>
            <pre><code class="language-javascript">
    // DESPUÉS: El flujo ahora es un proceso de varios pasos.
    // Paso 1: Obtener un token de autenticación general del servicio "Cloud".
    const tokenAPICloud = await Token.getToken();
    if (!tokenAPICloud) {
      Log.saveError(null, { message: 'Failed to get token from Cloud', /*...*/ });      
      return res.status(500).json({ message: 'Failed to get token from Cloud' });
    }
    
    // Paso 2: Construir los headers para la siguiente llamada, usando el token de Cloud.
    const headersToken = {
      headers: {
        'Authorization': `Bearer ${tokenAPICloud}`,
        'TraceKey':'1234',
        'TenantId':'d3186bc6d7b2'
      }
    }
    
    // Paso 3: Construir la URL y llamar a un endpoint específico para obtener el token de MercadoPago.
    let urlTokenMercadoPagoCloud = `${mercadoPago.credentials.data.mercadoPagoGetToken_uri}${user_id}`;
    if (!urlTokenMercadoPagoCloud) { /*...*/ }
    let tokenMercadoPagoCloud;
    try {
      tokenMercadoPagoCloud = await axios.get(urlTokenMercadoPagoCloud, headersToken);
    } catch (err) {
      return res.status(500).json({ message: 'Error fetching token from Cloud', /*...*/ });
    }
    if (!tokenMercadoPagoCloud) { /*...*/ }
    
    // Paso 4: Desencriptar el token de MercadoPago recibido.
    let decryptedTokenMercadoPagoCloud;
    try {
      decryptedTokenMercadoPagoCloud = await Token.decrypt(tokenMercadoPagoCloud?.data?.token);
    } catch (error) {
        return res.status(500).json({ message: 'Error decrypt token', /*...*/ });      
    }
    if (!decryptedTokenMercadoPagoCloud) { /*...*/ }
    
    // Paso 5: Usar el token desencriptado para la llamada final a la API de MercadoPago.
    const headersConfig = {
      headers: {
        'Authorization': `Bearer ${decryptedTokenMercadoPagoCloud}`
      }
    }
    // ...
            </code></pre>
            
            <h5>3. Validación y Manejo de Errores Mejorados</h5>
            <p><b>Explicación:</b> Se han añadido validaciones y un manejo de errores detallado para cada paso del nuevo flujo de autenticación.</p>
            <b>Código Nuevo (Ejemplos):</b>
            <pre><code class="language-javascript">
    // DESPUÉS: Se valida que el user_id exista en el cuerpo de la petición.
    if (!user_id || user_id === '' || user_id === 'undefined') {
      Log.saveError(null, { message: 'Missing user_id in request body', /*...*/ });     
      return res.status(400).json({ message: 'Falta user_id en la consulta' });
    }
    
    // DESPUÉS: Se valida que la configuración de la plataforma en la BD exista.
    if (!mercadoPago) {
      Log.saveError(null, { message: 'MercadoPago platform not found in DB', /*...*/ });
      return res.status(500).json({ message: 'MercadoPago platform not found in DB' });
    }
    
    // DESPUÉS: Se valida que la URL para obtener el token esté configurada.
    if (!urlTokenMercadoPagoCloud) {
      Log.saveError(null, { message: 'Missing MercadoPago token URL in platform credentials', /*...*/ });
      return res.status(500).json({ message: 'Missing MercadoPago token URL in platform credentials' });
    }
            </code></pre>
    
            <h5>4. Limpieza de Código</h5>
            <p><b>Explicación:</b> Se ha eliminado una gran cantidad de código comentado y lógica obsoleta que estaba relacionada con el antiguo método de manejo de tokens.</p>
            <b>Código Anterior:</b>
            <pre><code class="language-javascript">
    // ANTES: El archivo contenía múltiples bloques de código comentado, incluyendo lógica para actualizar tokens en la sucursal y un callback de OAuth.
    // let tokenMercadopago = currentBranch.mercadoPago.token
    /*
        if((currentBranch.mercadoPago.fecha - Date.now) > 150  || currentBranch.mercadoPago.token == '') { 
    // ... (muchas líneas de código comentado)
    // ***** code para obtener el frant type la primera vez ****** //
    // const callback = async (req, res) => {
    // ...
            </code></pre>
            <b>Código Nuevo:</b>
            <pre><code class="language-javascript">
    // DESPUÉS: Todo el código obsoleto ha sido eliminado, dejando solo la lógica funcional actual.
    // ... (código limpio)
    module.exports = { mercadoPagoNotification, initPlatform };
            </code></pre>
    
          <div class="analysis-box">
            <h4>Conclusión del análisis</h4>
            <p>La refactorización del controlador de MercadoPago es un cambio que mejora la seguridad:</p>
            <ul>
                <li><b>Centralización de Tokens:</b> La responsabilidad de gestionar los tokens de MercadoPago se traslada al Cloud.</li>
                <li><b>Seguridad Mejorada:</b> Los tokens ahora se transmiten encriptados y se desencriptan justo antes de su uso.</li>
                <li><b>Robustez:</b> El nuevo flujo incluye validaciones y manejo de errores.</li>
                <li><b>Calidad del Código:</b> La eliminación de código muerto y obsoleto.</li>
            </ul>
          </div>
        </div>
      </details>
          
          <details class="component-card">
  <summary class="component-header">
    <h3>api/src/platforms/interfaces/mercadoPago.js</h3>
  </summary>
  <div class="component-body">
      <h4>Análisis General</h4>
      <p>
        El cambio en este archivo es una corrección dentro del "parser" de MercadoPago. La modificación ajusta la función <code>detailsMapper</code> para reflejar con mayor precisión los datos que se le pasan, aunque el cambio funcional más relevante se infiere en cómo se utiliza el objeto <code>total</code> en otras partes del parser, como en <code>paymentenMapper</code>.
      </p>
      <p>
        El objetivo es alinear el código con una estructura de datos más detallada proveniente de la API de MercadoPago, permitiendo un mapeo más preciso de los diferentes componentes del total de la orden.
      </p>
      
      <h4>Cambios Detallados</h4>

      <h5>1. Cambio de Parámetro en la Firma de <code>detailsMapper</code></h5>
      <p><b>Explicación:</b> La función <code>detailsMapper</code>, responsable de procesar los artículos de una orden, ha cambiado su segundo parámetro de <code>discounts</code> a <code>total</code>. Aunque el nuevo parámetro <code>total</code> no se utiliza directamente dentro del cuerpo visible de <code>detailsMapper</code>, este cambio indica la forma en que se pasan los datos a las funciones del parser. La función que invoca a <code>detailsMapper</code> ahora le pasa el objeto <code>total</code> completo de la orden, en lugar de solo una parte.</p>
      <b>Código Anterior:</b>
      <pre><code class="language-javascript">
// ...
      const driverMapper = () => { /* ... */ };

      // ANTES: La función esperaba recibir específicamente el objeto 'discounts'.
      const detailsMapper = (items, discounts) => {
        try {
          let details = [];
          // ...
      </code></pre>
      <b>Código Nuevo:</b>
      <pre><code class="language-javascript">
// ...
      const driverMapper = () => { /* ... */ };

      // DESPUÉS: La función ahora espera recibir el objeto 'total' completo, que contiene los descuentos y otros datos de precios.
      const detailsMapper = (items, total) => {
        try {
          let details = [];
          // ...
      </code></pre>

    <div class="analysis-box">
      <h4>Conclusión del análisis</h4>
      <p>
        Este es un cambio de refactorización interna. Implica una mejora en la estructura de datos que se maneja dentro del parser. Al pasar el objeto <code>total</code> completo, se le da a la función <code>detailsMapper</code> acceso a un contexto de información de precios (<code>itemsPrice</code>, <code>otherFees</code>, <code>discount</code>).
      </p>
    </div>
  </div>
</details>
          
          <details class="component-card">
  <summary class="component-header">
    <h3>api/src/platforms/management/platform/mercadoPago.js</h3>
  </summary>
  <div class="component-body">
      <h4>Análisis General</h4>
      <p>
        Este archivo ha sido modificado extensamente para adoptar un nuevo sistema de <b>autenticación centralizado</b>, eliminando la gestión de tokens a nivel de sucursal.
      </p>
      <p>
        El nuevo flujo mejora la seguridad, la mantenibilidad y la robustez.
      </p>
      
      <h4>Cambios Detallados</h4>

      <h5>1. Refactorización de la Autenticación y Eliminación de <code>mercadoPagoClientModel</code></h5>
      <p><b>Explicación:</b> Se ha eliminado por completo el uso del modelo <code>mercadoPagoClientModel</code>, que antes gestionaba los tokens. La lógica para obtener el token de autorización de MercadoPago ha sido completamente rediseñada, introduciendo nuevas dependencias como <code>Token</code>, <code>PlatformModel</code> y <code>orderModel</code>.</p>
      <b>Código Anterior:</b>
      <pre><code class="language-javascript">
// ANTES: Se importaba 'mercadoPagoClientModel' para buscar tokens pre-almacenados.
import mercadoPagoClientModel from '../../../models/mercadoPagoClient';
import Log from '../../../utils/log';
      </code></pre>
      <b>Código Nuevo:</b>
      <pre><code class="language-javascript">
// DESPUÉS: Se elimina 'mercadoPagoClientModel' y se añaden modelos para buscar la orden completa y las credenciales de la plataforma.
import PlatformModel from '../../../models/platform';
import orderModel from '../../../models/order';
import Token from '../../../utils/token';
import Log from '../../../utils/log';
      </code></pre>

      <h5>2. Nuevo Flujo de Autenticación Unificado en <code>receiveOrder</code> y <code>branchRejectOrder</code></h5>
      <p><b>Explicación:</b> Tanto la función para aceptar (<code>receiveOrder</code>) como para rechazar (<code>branchRejectOrder</code>) una orden ahora siguen el mismo flujo para obtener un token de autorización en tiempo real.</p>
      <b>Código Anterior (en <code>receiveOrder</code>):</b>
      <pre><code class="language-javascript">
// ANTES: La lógica era simple: buscar el token en la base de datos y usarlo.
if (order.statusId === 1) {
  let mercadoPagoClient = await mercadoPagoClientModel.findOne({ branches: order.branchId});             
  let body = { "status": "accepted" };
  const headersConfig = {
    headers: {
     'Authorization': `Bearer ${mercadoPagoClient.token}`,
      'Content-Type': 'application/json'
    }
  };
  let url = `${this._platform.credentials.data.baseUrl}/proximity-integration/shipments/${order.id}/accept`;
  await axios.put(url, body, headersConfig);
  resolve(true);
}
      </code></pre>
      <b>Código Nuevo (Flujo implementado tanto en <code>receiveOrder</code> como en <code>branchRejectOrder</code>):</b>
      <pre><code class="language-javascript">
// DESPUÉS: Se implementa un flujo de múltiples pasos para obtener el token.

// Paso 1: Buscar la orden completa para obtener el 'user_id' del comerciante.
const fullOrder = await orderModel.findOne({ 'order.id': order.id });
const user_id = fullOrder?.order?.merchant?.id;
if (!user_id) { /* ... manejo de error ... */ }

// Paso 2: Obtener un token de autenticación general del servicio "Cloud".
const tokenAPICloud = Token.getToken();
if (!tokenAPICloud) { /* ... manejo de error ... */ }

// Paso 3: Construir headers y URL para obtener el token específico de MercadoPago.
const headersToken = { /* ... */ };
const urlTokenMercadoPagoCloud = `${mercadoPago.credentials.data.mercadoPagoGetToken_uri}${user_id}`;
if (!urlTokenMercadoPagoCloud) { /* ... manejo de error ... */ }

// Paso 4: Realizar la llamada para obtener el token encriptado.
let tokenMercadoPagoCloud;
try {
  tokenMercadoPagoCloud = await axios.get(urlTokenMercadoPagoCloud, headersToken);
} catch (err) { /* ... manejo de error ... */ }
if (!tokenMercadoPagoCloud?.data?.token) { /* ... manejo de error ... */ }

// Paso 5: Desencriptar el token de MercadoPago.
let decryptedTokenMercadoPagoCloud;
try {
  decryptedTokenMercadoPagoCloud = await Token.decrypt(tokenMercadoPagoCloud.data.token);
} catch (error) { /* ... manejo de error ... */ }
if (!decryptedTokenMercadoPagoCloud) { /* ... manejo de error ... */ }

// Paso 6: Usar el token final y desencriptado para la llamada a la API de MercadoPago.
const headersConfig = {
  headers: {
    'Authorization': `Bearer ${decryptedTokenMercadoPagoCloud}`,
    'Content-Type': 'application/json',
  }
};
// ... (llamada a axios.put para aceptar o cancelar la orden)
      </code></pre>
      
      <h5>3. Mejora en Logs y Manejo de Errores</h5>
      <p><b>Explicación:</b> Cada paso del flujo de obtención de tokens está ahora cubierto por bloques <code>try...catch</code> y registra logs detallados.</p>
      <b>Código Nuevo (Ejemplo en <code>branchRejectOrder</code>):</b>
      <pre><code class="language-javascript">
// DESPUÉS: Se añade un manejo de errores granular para cada paso crítico.
try {
  // ... (lógica de obtención de token)
  // ...
  try {
    await axios.put(url, body, headersConfig);
    Log.saveError(null, { message: 'branchRejectOrder passed MercadoPago', platform: 'MercadoPago' });
    resolve(true);
  } catch (error) {
    // DESPUÉS: El log de error ahora incluye la URL, el body y los headers de la petición fallida.
    Log.saveError(error, {
      message: 'Falló petición branchRejectOrder MercadoPago',
      url: url,
      body: body,
      headersConfig: headersConfig,
      platform: 'MercadoPago'
    });
    resolve(false);
  }
} catch (error) {
  // DESPUÉS: El bloque catch principal ahora loguea un objeto de error más estructurado.
  Log.saveError(error, {
    message: `Falló branchRejectOrder MercadoPago ${order.id}`,
    order,
    rejectMessageId,
    rejectMessageNote,
    platform: 'MercadoPago'
  });
  return false;
}
      </code></pre>
    <div class="analysis-box">
      <h4>Conclusión del análisis</h4>
      <p>Se abandona un modelo donde cada sucursal podría tener su propio token para pasar a un sistema centralizado que genera tokens dinámicamente.</p>
      <ul>
          <li><b>Centralización y Seguridad:</b> La lógica de autenticación se centraliza, y los tokens se manejan de forma más segura (encriptados y de corta duración).</li>
        <li><b>Robustez:</b> Agregado de validaciones y logs detallados.</li>
      </ul>
    </div>
  </div>
</details>
          
          <details class="component-card">
  <summary class="component-header">
    <h3>api/src/utils/token.js (Archivo Nuevo)</h3>
  </summary>
  <div class="component-body">
      <h4>Análisis General</h4>
      <p>
        Este es un archivo <b>nuevo</b> que introduce una clase <code>Token</code>.
      </p>
      <p>La clase <code>Token</code> tiene dos responsabilidades principales:</p>
      <ol>
        <li><b>Gestión Centralizada de Tokens:</b> Se encarga de obtener, cachear y renovar automáticamente los tokens de acceso necesarios para comunicarse con un el Cloud.</li>
        <li><b>Utilidad de Desencriptación:</b> Proporciona una función estática para desencriptar los tokens específicos de las plataformas (como MercadoPago).</li>
      </ol>
      
      <h4>Cambios Detallados (Análisis de la Nueva Clase)</h4>

      <h5>1. Gestión de Tokens</h5>
      <p><b>Explicación:</b> La clase implementa un Singleton con propiedades estáticas para manejar un único token de acceso para el servicio Cloud.</p>
      <b>Código y Lógica:</b>
      <pre><code class="language-javascript">
// ...
class Token {
    // ... (propiedades estáticas para token y expiración)
    
    // ANÁLISIS: Este método es el corazón de la gestión de tokens.
    // Comprueba si el token actual existe y si le quedan más de 200 segundos de vida.
    // Si no, invoca a CloudLogin para obtener uno nuevo.
    static async checkAndRenewToken() {
        const tiempoRestante = (this.expires_inDef - Date.now()) / 1000;
        if (!this.tokenSMLDef || tiempoRestante <= 200) {
            await this.CloudLogin();
        }
    }

    // ANÁLISIS: Realiza la llamada POST al endpoint de autenticación del servicio Cloud.
    // Utiliza las credenciales (client_id, client_secret) definidas en la configuración.
    // Si tiene éxito, guarda el nuevo token y calcula su fecha de expiración.
    static async CloudLogin() {
        try {
            const body = {
                client_id: settings.cloudParams.client_id,
                client_secret: settings.cloudParams.client_secret,
                audience: settings.cloudParams.audience
            }
            await axios.post(`${settings.cloudParams.url}`, body).then(r => {
                this.tokenCloudDef = r.data.access_token;
                this.expires_inDef = Date.now() + (r.data.expires_in * 1000);
            });
        } catch (error) {
            Log.saveError(error, { message: 'Falló CloudLogin', platform: 'Cloud' });
        }
    }

    // ANÁLISIS: Este es el método público que el resto de la aplicación debe usar.
    // Oculta toda la complejidad, asegurando que siempre se devuelva un token válido.
    static async getToken() {
        try {
            await this.checkAndRenewToken();
            return this.tokenCloudDef;
        } catch (error) {
            Log.saveError(error, { message: 'Falló getToken', platform: "Cloud" });
        }
    }
// ...
      </code></pre>

      <h5>2. Utilidad de Desencriptación</h5>
      <p><b>Explicación:</b> La clase proporciona un método estático <code>decrypt</code> para desencriptar texto. Está configurado para usar el algoritmo <code>aes-128-cbc</code> y utiliza una <code>Key</code> y un <code>IV</code> (Vector de Inicialización) que están fijos en el código.</p>
      <b>Código y Lógica:</b>
      <pre><code class="language-javascript">
// ...
class Token {
    // ANÁLISIS: Se definen la clave y el vector de inicialización como propiedades estáticas.
    // NOTA: Tener claves hardcodeadas es una práctica de seguridad riesgosa; idealmente, deberían venir de variables de entorno.
    static Key = '1234567890123456';
    static IV = '6543210987654321';
    // ...

    // ANÁLISIS: Método estático que toma un texto encriptado en base64 y lo devuelve desencriptado.
    static async decrypt(encryptedText) {
        console.log('entró token decrypt', encryptedText);

        if (!encryptedText) {
            throw new Error("Encrypted text is undefined or empty");
        }

        // ANÁLISIS: Se realizan validaciones para asegurar que la clave y el IV tengan la longitud correcta para el algoritmo AES-128.
        const keyBuffer = Buffer.from(this.Key, 'utf-8');
        const ivBuffer = Buffer.from(this.IV, 'utf-8');

        if (keyBuffer.length !== 16) {
            throw new Error(`Key length invalid: ${keyBuffer.length} bytes (should be 32)`);
        }
        if (ivBuffer.length !== 16) {
            throw new Error(`IV length invalid: ${ivBuffer.length} bytes (should be 16)`);
        }

        // ANÁLISIS: Se utiliza el módulo 'crypto' de Node.js para realizar la desencriptación.
        const decipher = crypto.createDecipheriv('aes-128-cbc', keyBuffer, ivBuffer);

        let decrypted = decipher.update(encryptedText, 'base64', 'utf-8');
        decrypted += decipher.final('utf-8');

        return decrypted;
    }
// ...
      </code></pre>

    <div class="analysis-box">
      <h4>Conclusión del análisis</h4>
      <p>La creación de <code>token.js</code> tiene estas caracteristicas:</p>
      <ul>
          <li><b>Centralización:</b> Abstrae por completo la lógica de autenticación con servicios externos.</li>
          <li><b>Seguridad:</b> Consolida las operaciones de seguridad (autenticación y desencriptación) en un único lugar.</li>
          <li><b>Mantenibilidad:</b> Simplifica enormemente el resto de la base de código.</li>
      </ul>
    </div>
  </div>
</details>
          
      
      </section>

  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>

</body>
</html>
